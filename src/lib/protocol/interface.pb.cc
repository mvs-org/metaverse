// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitcoin/protocol/interface.proto

#ifdef LIBBITCOIN_VERSION4

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "bitcoin/protocol/interface.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace libbitcoin {
namespace protocol {

namespace {

const ::google::protobuf::Descriptor* block_header_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  block_header_reflection_ = NULL;
const ::google::protobuf::Descriptor* point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  point_reflection_ = NULL;
const ::google::protobuf::Descriptor* tx_input_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tx_input_reflection_ = NULL;
const ::google::protobuf::Descriptor* tx_output_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tx_output_reflection_ = NULL;
const ::google::protobuf::Descriptor* tx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tx_reflection_ = NULL;
const ::google::protobuf::Descriptor* block_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  block_reflection_ = NULL;
const ::google::protobuf::Descriptor* filter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  filter_reflection_ = NULL;
const ::google::protobuf::Descriptor* block_id_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  block_id_reflection_ = NULL;
const ::google::protobuf::Descriptor* block_location_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  block_location_reflection_ = NULL;
const ::google::protobuf::Descriptor* tx_hash_result_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tx_hash_result_reflection_ = NULL;
const ::google::protobuf::Descriptor* tx_result_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tx_result_reflection_ = NULL;
const ::google::protobuf::Descriptor* output_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  output_reflection_ = NULL;
const ::google::protobuf::Descriptor* utxo_result_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  utxo_result_reflection_ = NULL;
const ::google::protobuf::Descriptor* block_headers_request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  block_headers_request_reflection_ = NULL;
const ::google::protobuf::Descriptor* transactions_request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  transactions_request_reflection_ = NULL;
const ::google::protobuf::Descriptor* request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  request_reflection_ = NULL;
struct requestOneofInstance {
  const ::libbitcoin::protocol::block_headers_request* get_block_headers_;
  const ::libbitcoin::protocol::transactions_request* get_transactions_;
  const ::libbitcoin::protocol::tx* post_transaction_;
  const ::libbitcoin::protocol::tx* validate_transaction_;
  const ::libbitcoin::protocol::block* post_block_;
  const ::libbitcoin::protocol::block* validate_block_;
}* request_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* response_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  response_reflection_ = NULL;
struct responseOneofInstance {
  const ::libbitcoin::protocol::response_block_headers* get_block_headers_response_;
  const ::libbitcoin::protocol::response_transactions* get_transactions_response_;
  bool post_transaction_succeeded_;
  bool validate_transaction_succeeded_;
  bool post_block_succeeded_;
  bool validate_block_succeeded_;
}* response_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* response_block_headers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  response_block_headers_reflection_ = NULL;
const ::google::protobuf::Descriptor* response_transactions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  response_transactions_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* filters_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* transaction_results_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* locations_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto() {
  protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "bitcoin/protocol/interface.proto");
  GOOGLE_CHECK(file != NULL);
  block_header_descriptor_ = file->message_type(0);
  static const int block_header_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, previous_block_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, merkle_root_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, tx_count_),
  };
  block_header_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      block_header_descriptor_,
      block_header::default_instance_,
      block_header_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_header, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(block_header));
  point_descriptor_ = file->message_type(1);
  static const int point_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(point, hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(point, index_),
  };
  point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      point_descriptor_,
      point::default_instance_,
      point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(point));
  tx_input_descriptor_ = file->message_type(2);
  static const int tx_input_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_input, previous_output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_input, script_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_input, sequence_),
  };
  tx_input_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tx_input_descriptor_,
      tx_input::default_instance_,
      tx_input_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_input, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_input, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tx_input));
  tx_output_descriptor_ = file->message_type(3);
  static const int tx_output_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_output, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_output, script_),
  };
  tx_output_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tx_output_descriptor_,
      tx_output::default_instance_,
      tx_output_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_output, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_output, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tx_output));
  tx_descriptor_ = file->message_type(4);
  static const int tx_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, locktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, outputs_),
  };
  tx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tx_descriptor_,
      tx::default_instance_,
      tx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tx));
  block_descriptor_ = file->message_type(5);
  static const int block_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block, transactions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block, tree_),
  };
  block_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      block_descriptor_,
      block::default_instance_,
      block_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(block));
  filter_descriptor_ = file->message_type(6);
  static const int filter_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(filter, filter_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(filter, bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(filter, prefix_),
  };
  filter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      filter_descriptor_,
      filter::default_instance_,
      filter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(filter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(filter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(filter));
  block_id_descriptor_ = file->message_type(7);
  static const int block_id_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_id, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_id, hash_),
  };
  block_id_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      block_id_descriptor_,
      block_id::default_instance_,
      block_id_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_id, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_id, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(block_id));
  block_location_descriptor_ = file->message_type(8);
  static const int block_location_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_location, identity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_location, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_location, branch_),
  };
  block_location_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      block_location_descriptor_,
      block_location::default_instance_,
      block_location_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_location, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_location, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(block_location));
  tx_hash_result_descriptor_ = file->message_type(9);
  static const int tx_hash_result_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_hash_result, hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_hash_result, location_),
  };
  tx_hash_result_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tx_hash_result_descriptor_,
      tx_hash_result::default_instance_,
      tx_hash_result_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_hash_result, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_hash_result, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tx_hash_result));
  tx_result_descriptor_ = file->message_type(10);
  static const int tx_result_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_result, transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_result, location_),
  };
  tx_result_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tx_result_descriptor_,
      tx_result::default_instance_,
      tx_result_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_result, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tx_result, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tx_result));
  output_descriptor_ = file->message_type(11);
  static const int output_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(output, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(output, satoshis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(output, script_),
  };
  output_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      output_descriptor_,
      output::default_instance_,
      output_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(output, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(output, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(output));
  utxo_result_descriptor_ = file->message_type(12);
  static const int utxo_result_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(utxo_result, tx_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(utxo_result, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(utxo_result, outputs_),
  };
  utxo_result_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      utxo_result_descriptor_,
      utxo_result::default_instance_,
      utxo_result_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(utxo_result, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(utxo_result, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(utxo_result));
  block_headers_request_descriptor_ = file->message_type(13);
  static const int block_headers_request_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_headers_request, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_headers_request, results_per_page_),
  };
  block_headers_request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      block_headers_request_descriptor_,
      block_headers_request::default_instance_,
      block_headers_request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_headers_request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(block_headers_request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(block_headers_request));
  transactions_request_descriptor_ = file->message_type(14);
  static const int transactions_request_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, results_per_page_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, result_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, location_type_),
  };
  transactions_request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      transactions_request_descriptor_,
      transactions_request::default_instance_,
      transactions_request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(transactions_request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(transactions_request));
  request_descriptor_ = file->message_type(15);
  static const int request_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, id_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, get_block_headers_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, get_transactions_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, post_transaction_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, validate_transaction_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, post_block_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(request_default_oneof_instance_, validate_block_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, request_type_),
  };
  request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      request_descriptor_,
      request::default_instance_,
      request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, _extensions_),
      request_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(request, _oneof_case_[0]),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(request));
  response_descriptor_ = file->message_type(16);
  static const int response_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, status_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, get_block_headers_response_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, get_transactions_response_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, post_transaction_succeeded_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, validate_transaction_succeeded_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, post_block_succeeded_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(response_default_oneof_instance_, validate_block_succeeded_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, response_type_),
  };
  response_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      response_descriptor_,
      response::default_instance_,
      response_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, _extensions_),
      response_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response, _oneof_case_[0]),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(response));
  response_block_headers_descriptor_ = response_descriptor_->nested_type(0);
  static const int response_block_headers_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_block_headers, next_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_block_headers, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_block_headers, headers_),
  };
  response_block_headers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      response_block_headers_descriptor_,
      response_block_headers::default_instance_,
      response_block_headers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_block_headers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_block_headers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(response_block_headers));
  response_transactions_descriptor_ = response_descriptor_->nested_type(1);
  static const int response_transactions_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, next_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, hashes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, transactions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, utxos_),
  };
  response_transactions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      response_transactions_descriptor_,
      response_transactions::default_instance_,
      response_transactions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(response_transactions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(response_transactions));
  filters_descriptor_ = file->enum_type(0);
  transaction_results_descriptor_ = file->enum_type(1);
  locations_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    block_header_descriptor_, &block_header::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    point_descriptor_, &point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tx_input_descriptor_, &tx_input::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tx_output_descriptor_, &tx_output::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tx_descriptor_, &tx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    block_descriptor_, &block::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    filter_descriptor_, &filter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    block_id_descriptor_, &block_id::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    block_location_descriptor_, &block_location::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tx_hash_result_descriptor_, &tx_hash_result::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tx_result_descriptor_, &tx_result::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    output_descriptor_, &output::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    utxo_result_descriptor_, &utxo_result::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    block_headers_request_descriptor_, &block_headers_request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    transactions_request_descriptor_, &transactions_request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    request_descriptor_, &request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    response_descriptor_, &response::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    response_block_headers_descriptor_, &response_block_headers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    response_transactions_descriptor_, &response_transactions::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto() {
  delete block_header::default_instance_;
  delete block_header_reflection_;
  delete point::default_instance_;
  delete point_reflection_;
  delete tx_input::default_instance_;
  delete tx_input_reflection_;
  delete tx_output::default_instance_;
  delete tx_output_reflection_;
  delete tx::default_instance_;
  delete tx_reflection_;
  delete block::default_instance_;
  delete block_reflection_;
  delete filter::default_instance_;
  delete filter_reflection_;
  delete block_id::default_instance_;
  delete block_id_reflection_;
  delete block_location::default_instance_;
  delete block_location_reflection_;
  delete tx_hash_result::default_instance_;
  delete tx_hash_result_reflection_;
  delete tx_result::default_instance_;
  delete tx_result_reflection_;
  delete output::default_instance_;
  delete output_reflection_;
  delete utxo_result::default_instance_;
  delete utxo_result_reflection_;
  delete block_headers_request::default_instance_;
  delete block_headers_request_reflection_;
  delete transactions_request::default_instance_;
  delete transactions_request_reflection_;
  delete request::default_instance_;
  delete request_default_oneof_instance_;
  delete request_reflection_;
  delete response::default_instance_;
  delete response_default_oneof_instance_;
  delete response_reflection_;
  delete response_block_headers::default_instance_;
  delete response_block_headers_reflection_;
  delete response_transactions::default_instance_;
  delete response_transactions_reflection_;
}

void protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n bitcoin/protocol/interface.proto\022\023libb"
    "itcoin.protocol\"\223\001\n\014block_header\022\017\n\007vers"
    "ion\030\001 \002(\r\022\033\n\023previous_block_hash\030\002 \002(\014\022\023"
    "\n\013merkle_root\030\003 \002(\014\022\021\n\ttimestamp\030\004 \002(\r\022\014"
    "\n\004bits\030\005 \002(\r\022\r\n\005nonce\030\006 \002(\r\022\020\n\010tx_count\030"
    "\007 \002(\004\"$\n\005point\022\014\n\004hash\030\001 \002(\014\022\r\n\005index\030\002 "
    "\002(\r\"a\n\010tx_input\0223\n\017previous_output\030\001 \002(\013"
    "2\032.libbitcoin.protocol.point\022\016\n\006script\030\002"
    " \002(\014\022\020\n\010sequence\030\003 \002(\r\"*\n\ttx_output\022\r\n\005v"
    "alue\030\001 \002(\004\022\016\n\006script\030\002 \002(\014\"\207\001\n\002tx\022\017\n\007ver"
    "sion\030\001 \002(\r\022\020\n\010locktime\030\002 \002(\r\022-\n\006inputs\030\003"
    " \003(\0132\035.libbitcoin.protocol.tx_input\022/\n\007o"
    "utputs\030\004 \003(\0132\036.libbitcoin.protocol.tx_ou"
    "tput\"w\n\005block\0221\n\006header\030\001 \002(\0132!.libbitco"
    "in.protocol.block_header\022-\n\014transactions"
    "\030\002 \003(\0132\027.libbitcoin.protocol.tx\022\014\n\004tree\030"
    "\003 \003(\014\"Y\n\006filter\0221\n\013filter_type\030\001 \002(\0162\034.l"
    "ibbitcoin.protocol.filters\022\014\n\004bits\030\002 \001(\r"
    "\022\016\n\006prefix\030\003 \002(\014\"(\n\010block_id\022\016\n\006height\030\001"
    " \001(\r\022\014\n\004hash\030\002 \001(\014\"`\n\016block_location\022/\n\010"
    "identity\030\001 \001(\0132\035.libbitcoin.protocol.blo"
    "ck_id\022\r\n\005index\030\002 \001(\004\022\016\n\006branch\030\003 \003(\014\"U\n\016"
    "tx_hash_result\022\014\n\004hash\030\001 \002(\014\0225\n\010location"
    "\030\002 \002(\0132#.libbitcoin.protocol.block_locat"
    "ion\"p\n\ttx_result\022,\n\013transaction\030\001 \002(\0132\027."
    "libbitcoin.protocol.tx\0225\n\010location\030\002 \002(\013"
    "2#.libbitcoin.protocol.block_location\"9\n"
    "\006output\022\r\n\005index\030\001 \002(\r\022\020\n\010satoshis\030\002 \002(\004"
    "\022\016\n\006script\030\003 \002(\014\"\203\001\n\013utxo_result\022\017\n\007tx_h"
    "ash\030\001 \002(\014\0225\n\010location\030\002 \002(\0132#.libbitcoin"
    ".protocol.block_location\022,\n\007outputs\030\003 \003("
    "\0132\033.libbitcoin.protocol.output\"_\n\025block_"
    "headers_request\022,\n\005start\030\001 \001(\0132\035.libbitc"
    "oin.protocol.block_id\022\030\n\020results_per_pag"
    "e\030\002 \001(\r\"\217\002\n\024transactions_request\022,\n\005star"
    "t\030\001 \001(\0132\035.libbitcoin.protocol.block_id\022\030"
    "\n\020results_per_page\030\002 \001(\r\022*\n\005query\030\003 \003(\0132"
    "\033.libbitcoin.protocol.filter\022F\n\013result_t"
    "ype\030\004 \001(\0162(.libbitcoin.protocol.transact"
    "ion_results:\007TX_HASH\022;\n\rlocation_type\030\005 "
    "\001(\0162\036.libbitcoin.protocol.locations:\004NON"
    "E\"\222\003\n\007request\022\n\n\002id\030\001 \002(\r\022G\n\021get_block_h"
    "eaders\030\002 \001(\0132*.libbitcoin.protocol.block"
    "_headers_requestH\000\022E\n\020get_transactions\030\003"
    " \001(\0132).libbitcoin.protocol.transactions_"
    "requestH\000\0223\n\020post_transaction\030\004 \001(\0132\027.li"
    "bbitcoin.protocol.txH\000\0227\n\024validate_trans"
    "action\030\005 \001(\0132\027.libbitcoin.protocol.txH\000\022"
    "0\n\npost_block\030\006 \001(\0132\032.libbitcoin.protoco"
    "l.blockH\000\0224\n\016validate_block\030\007 \001(\0132\032.libb"
    "itcoin.protocol.blockH\000*\005\010d\020\310\001B\016\n\014reques"
    "t_type\"\233\006\n\010response\022\n\n\002id\030\001 \002(\r\022\016\n\006statu"
    "s\030\002 \001(\021\022Q\n\032get_block_headers_response\030\003 "
    "\001(\0132+.libbitcoin.protocol.response.block"
    "_headersH\000\022O\n\031get_transactions_response\030"
    "\004 \001(\0132*.libbitcoin.protocol.response.tra"
    "nsactionsH\000\022$\n\032post_transaction_succeede"
    "d\030\005 \001(\010H\000\022(\n\036validate_transaction_succee"
    "ded\030\006 \001(\010H\000\022\036\n\024post_block_succeeded\030\007 \001("
    "\010H\000\022\"\n\030validate_block_succeeded\030\010 \001(\010H\000\032"
    "\234\001\n\rblock_headers\022+\n\004next\030\001 \001(\0132\035.libbit"
    "coin.protocol.block_id\022*\n\003top\030\002 \001(\0132\035.li"
    "bbitcoin.protocol.block_id\0222\n\007headers\030\003 "
    "\003(\0132!.libbitcoin.protocol.block_header\032\203"
    "\002\n\014transactions\022+\n\004next\030\001 \001(\0132\035.libbitco"
    "in.protocol.block_id\022*\n\003top\030\002 \001(\0132\035.libb"
    "itcoin.protocol.block_id\0223\n\006hashes\030\003 \003(\013"
    "2#.libbitcoin.protocol.tx_hash_result\0224\n"
    "\014transactions\030\004 \003(\0132\036.libbitcoin.protoco"
    "l.tx_result\022/\n\005utxos\030\005 \003(\0132 .libbitcoin."
    "protocol.utxo_result*\005\010d\020\310\001B\017\n\rresponse_"
    "type*4\n\007filters\022\013\n\007ADDRESS\020\001\022\017\n\013TRANSACT"
    "ION\020\002\022\013\n\007STEALTH\020\003*B\n\023transaction_result"
    "s\022\013\n\007TX_HASH\020\001\022\r\n\tTX_RESULT\020\002\022\017\n\013UTXO_RE"
    "SULT\020\003*,\n\tlocations\022\010\n\004NONE\020\000\022\t\n\005BLOCK\020\001"
    "\022\n\n\006MERKLE\020\002", 3012);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "bitcoin/protocol/interface.proto", &protobuf_RegisterTypes);
  block_header::default_instance_ = new block_header();
  point::default_instance_ = new point();
  tx_input::default_instance_ = new tx_input();
  tx_output::default_instance_ = new tx_output();
  tx::default_instance_ = new tx();
  block::default_instance_ = new block();
  filter::default_instance_ = new filter();
  block_id::default_instance_ = new block_id();
  block_location::default_instance_ = new block_location();
  tx_hash_result::default_instance_ = new tx_hash_result();
  tx_result::default_instance_ = new tx_result();
  output::default_instance_ = new output();
  utxo_result::default_instance_ = new utxo_result();
  block_headers_request::default_instance_ = new block_headers_request();
  transactions_request::default_instance_ = new transactions_request();
  request::default_instance_ = new request();
  request_default_oneof_instance_ = new requestOneofInstance;
  response::default_instance_ = new response();
  response_default_oneof_instance_ = new responseOneofInstance;
  response_block_headers::default_instance_ = new response_block_headers();
  response_transactions::default_instance_ = new response_transactions();
  block_header::default_instance_->InitAsDefaultInstance();
  point::default_instance_->InitAsDefaultInstance();
  tx_input::default_instance_->InitAsDefaultInstance();
  tx_output::default_instance_->InitAsDefaultInstance();
  tx::default_instance_->InitAsDefaultInstance();
  block::default_instance_->InitAsDefaultInstance();
  filter::default_instance_->InitAsDefaultInstance();
  block_id::default_instance_->InitAsDefaultInstance();
  block_location::default_instance_->InitAsDefaultInstance();
  tx_hash_result::default_instance_->InitAsDefaultInstance();
  tx_result::default_instance_->InitAsDefaultInstance();
  output::default_instance_->InitAsDefaultInstance();
  utxo_result::default_instance_->InitAsDefaultInstance();
  block_headers_request::default_instance_->InitAsDefaultInstance();
  transactions_request::default_instance_->InitAsDefaultInstance();
  request::default_instance_->InitAsDefaultInstance();
  response::default_instance_->InitAsDefaultInstance();
  response_block_headers::default_instance_->InitAsDefaultInstance();
  response_transactions::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_bitcoin_2fprotocol_2finterface_2eproto {
  StaticDescriptorInitializer_bitcoin_2fprotocol_2finterface_2eproto() {
    protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  }
} static_descriptor_initializer_bitcoin_2fprotocol_2finterface_2eproto_;
const ::google::protobuf::EnumDescriptor* filters_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return filters_descriptor_;
}
bool filters_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* transaction_results_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return transaction_results_descriptor_;
}
bool transaction_results_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* locations_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return locations_descriptor_;
}
bool locations_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int block_header::kVersionFieldNumber;
const int block_header::kPreviousBlockHashFieldNumber;
const int block_header::kMerkleRootFieldNumber;
const int block_header::kTimestampFieldNumber;
const int block_header::kBitsFieldNumber;
const int block_header::kNonceFieldNumber;
const int block_header::kTxCountFieldNumber;
#endif  // !_MSC_VER

block_header::block_header()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.block_header)
}

void block_header::InitAsDefaultInstance() {
}

block_header::block_header(const block_header& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.block_header)
}

void block_header::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 0u;
  previous_block_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  merkle_root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = 0u;
  bits_ = 0u;
  nonce_ = 0u;
  tx_count_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

block_header::~block_header() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.block_header)
  SharedDtor();
}

void block_header::SharedDtor() {
  if (previous_block_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete previous_block_hash_;
  }
  if (merkle_root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_root_;
  }
  if (this != default_instance_) {
  }
}

void block_header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* block_header::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return block_header_descriptor_;
}

const block_header& block_header::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

block_header* block_header::default_instance_ = NULL;

block_header* block_header::New() const {
  return new block_header;
}

void block_header::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<block_header*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(version_, timestamp_);
    ZR_(bits_, tx_count_);
    if (has_previous_block_hash()) {
      if (previous_block_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        previous_block_hash_->clear();
      }
    }
    if (has_merkle_root()) {
      if (merkle_root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        merkle_root_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool block_header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.block_header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_previous_block_hash;
        break;
      }

      // required bytes previous_block_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_previous_block_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_previous_block_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_merkle_root;
        break;
      }

      // required bytes merkle_root = 3;
      case 3: {
        if (tag == 26) {
         parse_merkle_root:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merkle_root()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // required uint32 timestamp = 4;
      case 4: {
        if (tag == 32) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_bits;
        break;
      }

      // required uint32 bits = 5;
      case 5: {
        if (tag == 40) {
         parse_bits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bits_)));
          set_has_bits();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_nonce;
        break;
      }

      // required uint32 nonce = 6;
      case 6: {
        if (tag == 48) {
         parse_nonce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nonce_)));
          set_has_nonce();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tx_count;
        break;
      }

      // required uint64 tx_count = 7;
      case 7: {
        if (tag == 56) {
         parse_tx_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_count_)));
          set_has_tx_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.block_header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.block_header)
  return false;
#undef DO_
}

void block_header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.block_header)
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required bytes previous_block_hash = 2;
  if (has_previous_block_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->previous_block_hash(), output);
  }

  // required bytes merkle_root = 3;
  if (has_merkle_root()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->merkle_root(), output);
  }

  // required uint32 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->timestamp(), output);
  }

  // required uint32 bits = 5;
  if (has_bits()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->bits(), output);
  }

  // required uint32 nonce = 6;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->nonce(), output);
  }

  // required uint64 tx_count = 7;
  if (has_tx_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->tx_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.block_header)
}

::google::protobuf::uint8* block_header::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.block_header)
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required bytes previous_block_hash = 2;
  if (has_previous_block_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->previous_block_hash(), target);
  }

  // required bytes merkle_root = 3;
  if (has_merkle_root()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->merkle_root(), target);
  }

  // required uint32 timestamp = 4;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->timestamp(), target);
  }

  // required uint32 bits = 5;
  if (has_bits()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->bits(), target);
  }

  // required uint32 nonce = 6;
  if (has_nonce()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->nonce(), target);
  }

  // required uint64 tx_count = 7;
  if (has_tx_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->tx_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.block_header)
  return target;
}

int block_header::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required bytes previous_block_hash = 2;
    if (has_previous_block_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->previous_block_hash());
    }

    // required bytes merkle_root = 3;
    if (has_merkle_root()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merkle_root());
    }

    // required uint32 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

    // required uint32 bits = 5;
    if (has_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits());
    }

    // required uint32 nonce = 6;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nonce());
    }

    // required uint64 tx_count = 7;
    if (has_tx_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void block_header::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const block_header* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const block_header*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void block_header::MergeFrom(const block_header& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_previous_block_hash()) {
      set_previous_block_hash(from.previous_block_hash());
    }
    if (from.has_merkle_root()) {
      set_merkle_root(from.merkle_root());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_bits()) {
      set_bits(from.bits());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_tx_count()) {
      set_tx_count(from.tx_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void block_header::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void block_header::CopyFrom(const block_header& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool block_header::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void block_header::Swap(block_header* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(previous_block_hash_, other->previous_block_hash_);
    std::swap(merkle_root_, other->merkle_root_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(bits_, other->bits_);
    std::swap(nonce_, other->nonce_);
    std::swap(tx_count_, other->tx_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata block_header::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = block_header_descriptor_;
  metadata.reflection = block_header_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int point::kHashFieldNumber;
const int point::kIndexFieldNumber;
#endif  // !_MSC_VER

point::point()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.point)
}

void point::InitAsDefaultInstance() {
}

point::point(const point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.point)
}

void point::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

point::~point() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.point)
  SharedDtor();
}

void point::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (this != default_instance_) {
  }
}

void point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return point_descriptor_;
}

const point& point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

point* point::default_instance_ = NULL;

point* point::New() const {
  return new point;
}

void point::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hash_->clear();
      }
    }
    index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // required uint32 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.point)
  return false;
#undef DO_
}

void point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.point)
  // required bytes hash = 1;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->hash(), output);
  }

  // required uint32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.point)
}

::google::protobuf::uint8* point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.point)
  // required bytes hash = 1;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->hash(), target);
  }

  // required uint32 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.point)
  return target;
}

int point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // required uint32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void point::MergeFrom(const point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hash()) {
      set_hash(from.hash());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void point::CopyFrom(const point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void point::Swap(point* other) {
  if (other != this) {
    std::swap(hash_, other->hash_);
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = point_descriptor_;
  metadata.reflection = point_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tx_input::kPreviousOutputFieldNumber;
const int tx_input::kScriptFieldNumber;
const int tx_input::kSequenceFieldNumber;
#endif  // !_MSC_VER

tx_input::tx_input()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.tx_input)
}

void tx_input::InitAsDefaultInstance() {
  previous_output_ = const_cast< ::libbitcoin::protocol::point*>(&::libbitcoin::protocol::point::default_instance());
}

tx_input::tx_input(const tx_input& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.tx_input)
}

void tx_input::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  previous_output_ = NULL;
  script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sequence_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tx_input::~tx_input() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.tx_input)
  SharedDtor();
}

void tx_input::SharedDtor() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (this != default_instance_) {
    delete previous_output_;
  }
}

void tx_input::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tx_input::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tx_input_descriptor_;
}

const tx_input& tx_input::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

tx_input* tx_input::default_instance_ = NULL;

tx_input* tx_input::New() const {
  return new tx_input;
}

void tx_input::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_previous_output()) {
      if (previous_output_ != NULL) previous_output_->::libbitcoin::protocol::point::Clear();
    }
    if (has_script()) {
      if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        script_->clear();
      }
    }
    sequence_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tx_input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.tx_input)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .libbitcoin.protocol.point previous_output = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_previous_output()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_script;
        break;
      }

      // required bytes script = 2;
      case 2: {
        if (tag == 18) {
         parse_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sequence;
        break;
      }

      // required uint32 sequence = 3;
      case 3: {
        if (tag == 24) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.tx_input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.tx_input)
  return false;
#undef DO_
}

void tx_input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.tx_input)
  // required .libbitcoin.protocol.point previous_output = 1;
  if (has_previous_output()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->previous_output(), output);
  }

  // required bytes script = 2;
  if (has_script()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->script(), output);
  }

  // required uint32 sequence = 3;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sequence(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.tx_input)
}

::google::protobuf::uint8* tx_input::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.tx_input)
  // required .libbitcoin.protocol.point previous_output = 1;
  if (has_previous_output()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->previous_output(), target);
  }

  // required bytes script = 2;
  if (has_script()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script(), target);
  }

  // required uint32 sequence = 3;
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->sequence(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.tx_input)
  return target;
}

int tx_input::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .libbitcoin.protocol.point previous_output = 1;
    if (has_previous_output()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->previous_output());
    }

    // required bytes script = 2;
    if (has_script()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script());
    }

    // required uint32 sequence = 3;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tx_input::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tx_input* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tx_input*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tx_input::MergeFrom(const tx_input& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_previous_output()) {
      mutable_previous_output()->::libbitcoin::protocol::point::MergeFrom(from.previous_output());
    }
    if (from.has_script()) {
      set_script(from.script());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tx_input::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tx_input::CopyFrom(const tx_input& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tx_input::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_previous_output()) {
    if (!this->previous_output().IsInitialized()) return false;
  }
  return true;
}

void tx_input::Swap(tx_input* other) {
  if (other != this) {
    std::swap(previous_output_, other->previous_output_);
    std::swap(script_, other->script_);
    std::swap(sequence_, other->sequence_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tx_input::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tx_input_descriptor_;
  metadata.reflection = tx_input_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tx_output::kValueFieldNumber;
const int tx_output::kScriptFieldNumber;
#endif  // !_MSC_VER

tx_output::tx_output()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.tx_output)
}

void tx_output::InitAsDefaultInstance() {
}

tx_output::tx_output(const tx_output& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.tx_output)
}

void tx_output::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = GOOGLE_ULONGLONG(0);
  script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tx_output::~tx_output() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.tx_output)
  SharedDtor();
}

void tx_output::SharedDtor() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (this != default_instance_) {
  }
}

void tx_output::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tx_output::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tx_output_descriptor_;
}

const tx_output& tx_output::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

tx_output* tx_output::default_instance_ = NULL;

tx_output* tx_output::New() const {
  return new tx_output;
}

void tx_output::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    value_ = GOOGLE_ULONGLONG(0);
    if (has_script()) {
      if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        script_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tx_output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.tx_output)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 value = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_script;
        break;
      }

      // required bytes script = 2;
      case 2: {
        if (tag == 18) {
         parse_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.tx_output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.tx_output)
  return false;
#undef DO_
}

void tx_output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.tx_output)
  // required uint64 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->value(), output);
  }

  // required bytes script = 2;
  if (has_script()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->script(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.tx_output)
}

::google::protobuf::uint8* tx_output::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.tx_output)
  // required uint64 value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->value(), target);
  }

  // required bytes script = 2;
  if (has_script()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.tx_output)
  return target;
}

int tx_output::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->value());
    }

    // required bytes script = 2;
    if (has_script()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tx_output::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tx_output* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tx_output*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tx_output::MergeFrom(const tx_output& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_script()) {
      set_script(from.script());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tx_output::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tx_output::CopyFrom(const tx_output& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tx_output::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void tx_output::Swap(tx_output* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(script_, other->script_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tx_output::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tx_output_descriptor_;
  metadata.reflection = tx_output_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tx::kVersionFieldNumber;
const int tx::kLocktimeFieldNumber;
const int tx::kInputsFieldNumber;
const int tx::kOutputsFieldNumber;
#endif  // !_MSC_VER

tx::tx()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.tx)
}

void tx::InitAsDefaultInstance() {
}

tx::tx(const tx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.tx)
}

void tx::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  locktime_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tx::~tx() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.tx)
  SharedDtor();
}

void tx::SharedDtor() {
  if (this != default_instance_) {
  }
}

void tx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tx_descriptor_;
}

const tx& tx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

tx* tx::default_instance_ = NULL;

tx* tx::New() const {
  return new tx;
}

void tx::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<tx*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(version_, locktime_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  inputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.tx)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_locktime;
        break;
      }

      // required uint32 locktime = 2;
      case 2: {
        if (tag == 16) {
         parse_locktime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &locktime_)));
          set_has_locktime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inputs;
        break;
      }

      // repeated .libbitcoin.protocol.tx_input inputs = 3;
      case 3: {
        if (tag == 26) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inputs;
        if (input->ExpectTag(34)) goto parse_outputs;
        break;
      }

      // repeated .libbitcoin.protocol.tx_output outputs = 4;
      case 4: {
        if (tag == 34) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_outputs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.tx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.tx)
  return false;
#undef DO_
}

void tx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.tx)
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint32 locktime = 2;
  if (has_locktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->locktime(), output);
  }

  // repeated .libbitcoin.protocol.tx_input inputs = 3;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->inputs(i), output);
  }

  // repeated .libbitcoin.protocol.tx_output outputs = 4;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->outputs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.tx)
}

::google::protobuf::uint8* tx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.tx)
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint32 locktime = 2;
  if (has_locktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->locktime(), target);
  }

  // repeated .libbitcoin.protocol.tx_input inputs = 3;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->inputs(i), target);
  }

  // repeated .libbitcoin.protocol.tx_output outputs = 4;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->outputs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.tx)
  return target;
}

int tx::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 locktime = 2;
    if (has_locktime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->locktime());
    }

  }
  // repeated .libbitcoin.protocol.tx_input inputs = 3;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inputs(i));
  }

  // repeated .libbitcoin.protocol.tx_output outputs = 4;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tx::MergeFrom(const tx& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_locktime()) {
      set_locktime(from.locktime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tx::CopyFrom(const tx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->inputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->outputs())) return false;
  return true;
}

void tx::Swap(tx* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(locktime_, other->locktime_);
    inputs_.Swap(&other->inputs_);
    outputs_.Swap(&other->outputs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tx_descriptor_;
  metadata.reflection = tx_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int block::kHeaderFieldNumber;
const int block::kTransactionsFieldNumber;
const int block::kTreeFieldNumber;
#endif  // !_MSC_VER

block::block()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.block)
}

void block::InitAsDefaultInstance() {
  header_ = const_cast< ::libbitcoin::protocol::block_header*>(&::libbitcoin::protocol::block_header::default_instance());
}

block::block(const block& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.block)
}

void block::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

block::~block() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.block)
  SharedDtor();
}

void block::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void block::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* block::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return block_descriptor_;
}

const block& block::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

block* block::default_instance_ = NULL;

block* block::New() const {
  return new block;
}

void block::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::libbitcoin::protocol::block_header::Clear();
  }
  transactions_.Clear();
  tree_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool block::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.block)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .libbitcoin.protocol.block_header header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_transactions;
        break;
      }

      // repeated .libbitcoin.protocol.tx transactions = 2;
      case 2: {
        if (tag == 18) {
         parse_transactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transactions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_transactions;
        if (input->ExpectTag(26)) goto parse_tree;
        break;
      }

      // repeated bytes tree = 3;
      case 3: {
        if (tag == 26) {
         parse_tree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_tree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tree;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.block)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.block)
  return false;
#undef DO_
}

void block::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.block)
  // required .libbitcoin.protocol.block_header header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // repeated .libbitcoin.protocol.tx transactions = 2;
  for (int i = 0; i < this->transactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->transactions(i), output);
  }

  // repeated bytes tree = 3;
  for (int i = 0; i < this->tree_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->tree(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.block)
}

::google::protobuf::uint8* block::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.block)
  // required .libbitcoin.protocol.block_header header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // repeated .libbitcoin.protocol.tx transactions = 2;
  for (int i = 0; i < this->transactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->transactions(i), target);
  }

  // repeated bytes tree = 3;
  for (int i = 0; i < this->tree_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->tree(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.block)
  return target;
}

int block::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .libbitcoin.protocol.block_header header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

  }
  // repeated .libbitcoin.protocol.tx transactions = 2;
  total_size += 1 * this->transactions_size();
  for (int i = 0; i < this->transactions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transactions(i));
  }

  // repeated bytes tree = 3;
  total_size += 1 * this->tree_size();
  for (int i = 0; i < this->tree_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->tree(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void block::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const block* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const block*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void block::MergeFrom(const block& from) {
  GOOGLE_CHECK_NE(&from, this);
  transactions_.MergeFrom(from.transactions_);
  tree_.MergeFrom(from.tree_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::libbitcoin::protocol::block_header::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void block::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void block::CopyFrom(const block& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool block::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->transactions())) return false;
  return true;
}

void block::Swap(block* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    transactions_.Swap(&other->transactions_);
    tree_.Swap(&other->tree_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata block::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = block_descriptor_;
  metadata.reflection = block_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int filter::kFilterTypeFieldNumber;
const int filter::kBitsFieldNumber;
const int filter::kPrefixFieldNumber;
#endif  // !_MSC_VER

filter::filter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.filter)
}

void filter::InitAsDefaultInstance() {
}

filter::filter(const filter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.filter)
}

void filter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  filter_type_ = 1;
  bits_ = 0u;
  prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

filter::~filter() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.filter)
  SharedDtor();
}

void filter::SharedDtor() {
  if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prefix_;
  }
  if (this != default_instance_) {
  }
}

void filter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* filter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return filter_descriptor_;
}

const filter& filter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

filter* filter::default_instance_ = NULL;

filter* filter::New() const {
  return new filter;
}

void filter::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    filter_type_ = 1;
    bits_ = 0u;
    if (has_prefix()) {
      if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        prefix_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool filter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.filter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .libbitcoin.protocol.filters filter_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::libbitcoin::protocol::filters_IsValid(value)) {
            set_filter_type(static_cast< ::libbitcoin::protocol::filters >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bits;
        break;
      }

      // optional uint32 bits = 2;
      case 2: {
        if (tag == 16) {
         parse_bits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bits_)));
          set_has_bits();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_prefix;
        break;
      }

      // required bytes prefix = 3;
      case 3: {
        if (tag == 26) {
         parse_prefix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prefix()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.filter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.filter)
  return false;
#undef DO_
}

void filter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.filter)
  // required .libbitcoin.protocol.filters filter_type = 1;
  if (has_filter_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->filter_type(), output);
  }

  // optional uint32 bits = 2;
  if (has_bits()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bits(), output);
  }

  // required bytes prefix = 3;
  if (has_prefix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->prefix(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.filter)
}

::google::protobuf::uint8* filter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.filter)
  // required .libbitcoin.protocol.filters filter_type = 1;
  if (has_filter_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->filter_type(), target);
  }

  // optional uint32 bits = 2;
  if (has_bits()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bits(), target);
  }

  // required bytes prefix = 3;
  if (has_prefix()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->prefix(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.filter)
  return target;
}

int filter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .libbitcoin.protocol.filters filter_type = 1;
    if (has_filter_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_type());
    }

    // optional uint32 bits = 2;
    if (has_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits());
    }

    // required bytes prefix = 3;
    if (has_prefix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prefix());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void filter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const filter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const filter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void filter::MergeFrom(const filter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_type()) {
      set_filter_type(from.filter_type());
    }
    if (from.has_bits()) {
      set_bits(from.bits());
    }
    if (from.has_prefix()) {
      set_prefix(from.prefix());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void filter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void filter::CopyFrom(const filter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool filter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  return true;
}

void filter::Swap(filter* other) {
  if (other != this) {
    std::swap(filter_type_, other->filter_type_);
    std::swap(bits_, other->bits_);
    std::swap(prefix_, other->prefix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata filter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = filter_descriptor_;
  metadata.reflection = filter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int block_id::kHeightFieldNumber;
const int block_id::kHashFieldNumber;
#endif  // !_MSC_VER

block_id::block_id()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.block_id)
}

void block_id::InitAsDefaultInstance() {
}

block_id::block_id(const block_id& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.block_id)
}

void block_id::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  height_ = 0u;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

block_id::~block_id() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.block_id)
  SharedDtor();
}

void block_id::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (this != default_instance_) {
  }
}

void block_id::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* block_id::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return block_id_descriptor_;
}

const block_id& block_id::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

block_id* block_id::default_instance_ = NULL;

block_id* block_id::New() const {
  return new block_id;
}

void block_id::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    height_ = 0u;
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool block_id::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.block_id)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 height = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_hash;
        break;
      }

      // optional bytes hash = 2;
      case 2: {
        if (tag == 18) {
         parse_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.block_id)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.block_id)
  return false;
#undef DO_
}

void block_id::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.block_id)
  // optional uint32 height = 1;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->height(), output);
  }

  // optional bytes hash = 2;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.block_id)
}

::google::protobuf::uint8* block_id::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.block_id)
  // optional uint32 height = 1;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->height(), target);
  }

  // optional bytes hash = 2;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.block_id)
  return target;
}

int block_id::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 height = 1;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height());
    }

    // optional bytes hash = 2;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void block_id::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const block_id* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const block_id*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void block_id::MergeFrom(const block_id& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_hash()) {
      set_hash(from.hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void block_id::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void block_id::CopyFrom(const block_id& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool block_id::IsInitialized() const {

  return true;
}

void block_id::Swap(block_id* other) {
  if (other != this) {
    std::swap(height_, other->height_);
    std::swap(hash_, other->hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata block_id::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = block_id_descriptor_;
  metadata.reflection = block_id_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int block_location::kIdentityFieldNumber;
const int block_location::kIndexFieldNumber;
const int block_location::kBranchFieldNumber;
#endif  // !_MSC_VER

block_location::block_location()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.block_location)
}

void block_location::InitAsDefaultInstance() {
  identity_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
}

block_location::block_location(const block_location& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.block_location)
}

void block_location::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  identity_ = NULL;
  index_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

block_location::~block_location() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.block_location)
  SharedDtor();
}

void block_location::SharedDtor() {
  if (this != default_instance_) {
    delete identity_;
  }
}

void block_location::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* block_location::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return block_location_descriptor_;
}

const block_location& block_location::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

block_location* block_location::default_instance_ = NULL;

block_location* block_location::New() const {
  return new block_location;
}

void block_location::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_identity()) {
      if (identity_ != NULL) identity_->::libbitcoin::protocol::block_id::Clear();
    }
    index_ = GOOGLE_ULONGLONG(0);
  }
  branch_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool block_location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.block_location)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libbitcoin.protocol.block_id identity = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional uint64 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_branch;
        break;
      }

      // repeated bytes branch = 3;
      case 3: {
        if (tag == 26) {
         parse_branch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_branch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_branch;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.block_location)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.block_location)
  return false;
#undef DO_
}

void block_location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.block_location)
  // optional .libbitcoin.protocol.block_id identity = 1;
  if (has_identity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->identity(), output);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->index(), output);
  }

  // repeated bytes branch = 3;
  for (int i = 0; i < this->branch_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->branch(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.block_location)
}

::google::protobuf::uint8* block_location::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.block_location)
  // optional .libbitcoin.protocol.block_id identity = 1;
  if (has_identity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->identity(), target);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->index(), target);
  }

  // repeated bytes branch = 3;
  for (int i = 0; i < this->branch_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->branch(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.block_location)
  return target;
}

int block_location::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .libbitcoin.protocol.block_id identity = 1;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->identity());
    }

    // optional uint64 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->index());
    }

  }
  // repeated bytes branch = 3;
  total_size += 1 * this->branch_size();
  for (int i = 0; i < this->branch_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->branch(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void block_location::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const block_location* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const block_location*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void block_location::MergeFrom(const block_location& from) {
  GOOGLE_CHECK_NE(&from, this);
  branch_.MergeFrom(from.branch_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_identity()) {
      mutable_identity()->::libbitcoin::protocol::block_id::MergeFrom(from.identity());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void block_location::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void block_location::CopyFrom(const block_location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool block_location::IsInitialized() const {

  return true;
}

void block_location::Swap(block_location* other) {
  if (other != this) {
    std::swap(identity_, other->identity_);
    std::swap(index_, other->index_);
    branch_.Swap(&other->branch_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata block_location::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = block_location_descriptor_;
  metadata.reflection = block_location_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tx_hash_result::kHashFieldNumber;
const int tx_hash_result::kLocationFieldNumber;
#endif  // !_MSC_VER

tx_hash_result::tx_hash_result()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.tx_hash_result)
}

void tx_hash_result::InitAsDefaultInstance() {
  location_ = const_cast< ::libbitcoin::protocol::block_location*>(&::libbitcoin::protocol::block_location::default_instance());
}

tx_hash_result::tx_hash_result(const tx_hash_result& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.tx_hash_result)
}

void tx_hash_result::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tx_hash_result::~tx_hash_result() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.tx_hash_result)
  SharedDtor();
}

void tx_hash_result::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (this != default_instance_) {
    delete location_;
  }
}

void tx_hash_result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tx_hash_result::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tx_hash_result_descriptor_;
}

const tx_hash_result& tx_hash_result::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

tx_hash_result* tx_hash_result::default_instance_ = NULL;

tx_hash_result* tx_hash_result::New() const {
  return new tx_hash_result;
}

void tx_hash_result::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hash_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tx_hash_result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.tx_hash_result)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_location;
        break;
      }

      // required .libbitcoin.protocol.block_location location = 2;
      case 2: {
        if (tag == 18) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.tx_hash_result)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.tx_hash_result)
  return false;
#undef DO_
}

void tx_hash_result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.tx_hash_result)
  // required bytes hash = 1;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->hash(), output);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->location(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.tx_hash_result)
}

::google::protobuf::uint8* tx_hash_result::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.tx_hash_result)
  // required bytes hash = 1;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->hash(), target);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->location(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.tx_hash_result)
  return target;
}

int tx_hash_result::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // required .libbitcoin.protocol.block_location location = 2;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tx_hash_result::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tx_hash_result* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tx_hash_result*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tx_hash_result::MergeFrom(const tx_hash_result& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hash()) {
      set_hash(from.hash());
    }
    if (from.has_location()) {
      mutable_location()->::libbitcoin::protocol::block_location::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tx_hash_result::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tx_hash_result::CopyFrom(const tx_hash_result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tx_hash_result::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void tx_hash_result::Swap(tx_hash_result* other) {
  if (other != this) {
    std::swap(hash_, other->hash_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tx_hash_result::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tx_hash_result_descriptor_;
  metadata.reflection = tx_hash_result_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tx_result::kTransactionFieldNumber;
const int tx_result::kLocationFieldNumber;
#endif  // !_MSC_VER

tx_result::tx_result()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.tx_result)
}

void tx_result::InitAsDefaultInstance() {
  transaction_ = const_cast< ::libbitcoin::protocol::tx*>(&::libbitcoin::protocol::tx::default_instance());
  location_ = const_cast< ::libbitcoin::protocol::block_location*>(&::libbitcoin::protocol::block_location::default_instance());
}

tx_result::tx_result(const tx_result& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.tx_result)
}

void tx_result::SharedCtor() {
  _cached_size_ = 0;
  transaction_ = NULL;
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tx_result::~tx_result() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.tx_result)
  SharedDtor();
}

void tx_result::SharedDtor() {
  if (this != default_instance_) {
    delete transaction_;
    delete location_;
  }
}

void tx_result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tx_result::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tx_result_descriptor_;
}

const tx_result& tx_result::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

tx_result* tx_result::default_instance_ = NULL;

tx_result* tx_result::New() const {
  return new tx_result;
}

void tx_result::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_transaction()) {
      if (transaction_ != NULL) transaction_->::libbitcoin::protocol::tx::Clear();
    }
    if (has_location()) {
      if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tx_result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.tx_result)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .libbitcoin.protocol.tx transaction = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_location;
        break;
      }

      // required .libbitcoin.protocol.block_location location = 2;
      case 2: {
        if (tag == 18) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.tx_result)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.tx_result)
  return false;
#undef DO_
}

void tx_result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.tx_result)
  // required .libbitcoin.protocol.tx transaction = 1;
  if (has_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->transaction(), output);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->location(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.tx_result)
}

::google::protobuf::uint8* tx_result::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.tx_result)
  // required .libbitcoin.protocol.tx transaction = 1;
  if (has_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->transaction(), target);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->location(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.tx_result)
  return target;
}

int tx_result::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .libbitcoin.protocol.tx transaction = 1;
    if (has_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transaction());
    }

    // required .libbitcoin.protocol.block_location location = 2;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tx_result::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tx_result* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tx_result*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tx_result::MergeFrom(const tx_result& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction()) {
      mutable_transaction()->::libbitcoin::protocol::tx::MergeFrom(from.transaction());
    }
    if (from.has_location()) {
      mutable_location()->::libbitcoin::protocol::block_location::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tx_result::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tx_result::CopyFrom(const tx_result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tx_result::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_transaction()) {
    if (!this->transaction().IsInitialized()) return false;
  }
  return true;
}

void tx_result::Swap(tx_result* other) {
  if (other != this) {
    std::swap(transaction_, other->transaction_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tx_result::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tx_result_descriptor_;
  metadata.reflection = tx_result_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int output::kIndexFieldNumber;
const int output::kSatoshisFieldNumber;
const int output::kScriptFieldNumber;
#endif  // !_MSC_VER

output::output()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.output)
}

void output::InitAsDefaultInstance() {
}

output::output(const output& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.output)
}

void output::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0u;
  satoshis_ = GOOGLE_ULONGLONG(0);
  script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

output::~output() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.output)
  SharedDtor();
}

void output::SharedDtor() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (this != default_instance_) {
  }
}

void output::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* output::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return output_descriptor_;
}

const output& output::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

output* output::default_instance_ = NULL;

output* output::New() const {
  return new output;
}

void output::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    index_ = 0u;
    satoshis_ = GOOGLE_ULONGLONG(0);
    if (has_script()) {
      if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        script_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.output)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_satoshis;
        break;
      }

      // required uint64 satoshis = 2;
      case 2: {
        if (tag == 16) {
         parse_satoshis:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &satoshis_)));
          set_has_satoshis();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_script;
        break;
      }

      // required bytes script = 3;
      case 3: {
        if (tag == 26) {
         parse_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.output)
  return false;
#undef DO_
}

void output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.output)
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required uint64 satoshis = 2;
  if (has_satoshis()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->satoshis(), output);
  }

  // required bytes script = 3;
  if (has_script()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->script(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.output)
}

::google::protobuf::uint8* output::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.output)
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // required uint64 satoshis = 2;
  if (has_satoshis()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->satoshis(), target);
  }

  // required bytes script = 3;
  if (has_script()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->script(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.output)
  return target;
}

int output::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required uint64 satoshis = 2;
    if (has_satoshis()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->satoshis());
    }

    // required bytes script = 3;
    if (has_script()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void output::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const output* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const output*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void output::MergeFrom(const output& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_satoshis()) {
      set_satoshis(from.satoshis());
    }
    if (from.has_script()) {
      set_script(from.script());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void output::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void output::CopyFrom(const output& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool output::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void output::Swap(output* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(satoshis_, other->satoshis_);
    std::swap(script_, other->script_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata output::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = output_descriptor_;
  metadata.reflection = output_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int utxo_result::kTxHashFieldNumber;
const int utxo_result::kLocationFieldNumber;
const int utxo_result::kOutputsFieldNumber;
#endif  // !_MSC_VER

utxo_result::utxo_result()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.utxo_result)
}

void utxo_result::InitAsDefaultInstance() {
  location_ = const_cast< ::libbitcoin::protocol::block_location*>(&::libbitcoin::protocol::block_location::default_instance());
}

utxo_result::utxo_result(const utxo_result& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.utxo_result)
}

void utxo_result::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

utxo_result::~utxo_result() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.utxo_result)
  SharedDtor();
}

void utxo_result::SharedDtor() {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_hash_;
  }
  if (this != default_instance_) {
    delete location_;
  }
}

void utxo_result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* utxo_result::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return utxo_result_descriptor_;
}

const utxo_result& utxo_result::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

utxo_result* utxo_result::default_instance_ = NULL;

utxo_result* utxo_result::New() const {
  return new utxo_result;
}

void utxo_result::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_tx_hash()) {
      if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tx_hash_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
    }
  }
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool utxo_result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.utxo_result)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes tx_hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tx_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_location;
        break;
      }

      // required .libbitcoin.protocol.block_location location = 2;
      case 2: {
        if (tag == 18) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_outputs;
        break;
      }

      // repeated .libbitcoin.protocol.output outputs = 3;
      case 3: {
        if (tag == 26) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_outputs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.utxo_result)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.utxo_result)
  return false;
#undef DO_
}

void utxo_result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.utxo_result)
  // required bytes tx_hash = 1;
  if (has_tx_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->tx_hash(), output);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->location(), output);
  }

  // repeated .libbitcoin.protocol.output outputs = 3;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->outputs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.utxo_result)
}

::google::protobuf::uint8* utxo_result::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.utxo_result)
  // required bytes tx_hash = 1;
  if (has_tx_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->tx_hash(), target);
  }

  // required .libbitcoin.protocol.block_location location = 2;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->location(), target);
  }

  // repeated .libbitcoin.protocol.output outputs = 3;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->outputs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.utxo_result)
  return target;
}

int utxo_result::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes tx_hash = 1;
    if (has_tx_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tx_hash());
    }

    // required .libbitcoin.protocol.block_location location = 2;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  // repeated .libbitcoin.protocol.output outputs = 3;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void utxo_result::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const utxo_result* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const utxo_result*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void utxo_result::MergeFrom(const utxo_result& from) {
  GOOGLE_CHECK_NE(&from, this);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tx_hash()) {
      set_tx_hash(from.tx_hash());
    }
    if (from.has_location()) {
      mutable_location()->::libbitcoin::protocol::block_location::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void utxo_result::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void utxo_result::CopyFrom(const utxo_result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool utxo_result::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->outputs())) return false;
  return true;
}

void utxo_result::Swap(utxo_result* other) {
  if (other != this) {
    std::swap(tx_hash_, other->tx_hash_);
    std::swap(location_, other->location_);
    outputs_.Swap(&other->outputs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata utxo_result::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = utxo_result_descriptor_;
  metadata.reflection = utxo_result_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int block_headers_request::kStartFieldNumber;
const int block_headers_request::kResultsPerPageFieldNumber;
#endif  // !_MSC_VER

block_headers_request::block_headers_request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.block_headers_request)
}

void block_headers_request::InitAsDefaultInstance() {
  start_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
}

block_headers_request::block_headers_request(const block_headers_request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.block_headers_request)
}

void block_headers_request::SharedCtor() {
  _cached_size_ = 0;
  start_ = NULL;
  results_per_page_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

block_headers_request::~block_headers_request() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.block_headers_request)
  SharedDtor();
}

void block_headers_request::SharedDtor() {
  if (this != default_instance_) {
    delete start_;
  }
}

void block_headers_request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* block_headers_request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return block_headers_request_descriptor_;
}

const block_headers_request& block_headers_request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

block_headers_request* block_headers_request::default_instance_ = NULL;

block_headers_request* block_headers_request::New() const {
  return new block_headers_request;
}

void block_headers_request::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_start()) {
      if (start_ != NULL) start_->::libbitcoin::protocol::block_id::Clear();
    }
    results_per_page_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool block_headers_request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.block_headers_request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libbitcoin.protocol.block_id start = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_results_per_page;
        break;
      }

      // optional uint32 results_per_page = 2;
      case 2: {
        if (tag == 16) {
         parse_results_per_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &results_per_page_)));
          set_has_results_per_page();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.block_headers_request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.block_headers_request)
  return false;
#undef DO_
}

void block_headers_request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.block_headers_request)
  // optional .libbitcoin.protocol.block_id start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->start(), output);
  }

  // optional uint32 results_per_page = 2;
  if (has_results_per_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->results_per_page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.block_headers_request)
}

::google::protobuf::uint8* block_headers_request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.block_headers_request)
  // optional .libbitcoin.protocol.block_id start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->start(), target);
  }

  // optional uint32 results_per_page = 2;
  if (has_results_per_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->results_per_page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.block_headers_request)
  return target;
}

int block_headers_request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .libbitcoin.protocol.block_id start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->start());
    }

    // optional uint32 results_per_page = 2;
    if (has_results_per_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->results_per_page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void block_headers_request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const block_headers_request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const block_headers_request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void block_headers_request::MergeFrom(const block_headers_request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      mutable_start()->::libbitcoin::protocol::block_id::MergeFrom(from.start());
    }
    if (from.has_results_per_page()) {
      set_results_per_page(from.results_per_page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void block_headers_request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void block_headers_request::CopyFrom(const block_headers_request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool block_headers_request::IsInitialized() const {

  return true;
}

void block_headers_request::Swap(block_headers_request* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    std::swap(results_per_page_, other->results_per_page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata block_headers_request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = block_headers_request_descriptor_;
  metadata.reflection = block_headers_request_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int transactions_request::kStartFieldNumber;
const int transactions_request::kResultsPerPageFieldNumber;
const int transactions_request::kQueryFieldNumber;
const int transactions_request::kResultTypeFieldNumber;
const int transactions_request::kLocationTypeFieldNumber;
#endif  // !_MSC_VER

transactions_request::transactions_request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.transactions_request)
}

void transactions_request::InitAsDefaultInstance() {
  start_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
}

transactions_request::transactions_request(const transactions_request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.transactions_request)
}

void transactions_request::SharedCtor() {
  _cached_size_ = 0;
  start_ = NULL;
  results_per_page_ = 0u;
  result_type_ = 1;
  location_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

transactions_request::~transactions_request() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.transactions_request)
  SharedDtor();
}

void transactions_request::SharedDtor() {
  if (this != default_instance_) {
    delete start_;
  }
}

void transactions_request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* transactions_request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return transactions_request_descriptor_;
}

const transactions_request& transactions_request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

transactions_request* transactions_request::default_instance_ = NULL;

transactions_request* transactions_request::New() const {
  return new transactions_request;
}

void transactions_request::Clear() {
  if (_has_bits_[0 / 32] & 27) {
    if (has_start()) {
      if (start_ != NULL) start_->::libbitcoin::protocol::block_id::Clear();
    }
    results_per_page_ = 0u;
    result_type_ = 1;
    location_type_ = 0;
  }
  query_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool transactions_request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.transactions_request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libbitcoin.protocol.block_id start = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_results_per_page;
        break;
      }

      // optional uint32 results_per_page = 2;
      case 2: {
        if (tag == 16) {
         parse_results_per_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &results_per_page_)));
          set_has_results_per_page();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_query;
        break;
      }

      // repeated .libbitcoin.protocol.filter query = 3;
      case 3: {
        if (tag == 26) {
         parse_query:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_query()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_query;
        if (input->ExpectTag(32)) goto parse_result_type;
        break;
      }

      // optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
      case 4: {
        if (tag == 32) {
         parse_result_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::libbitcoin::protocol::transaction_results_IsValid(value)) {
            set_result_type(static_cast< ::libbitcoin::protocol::transaction_results >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_location_type;
        break;
      }

      // optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
      case 5: {
        if (tag == 40) {
         parse_location_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::libbitcoin::protocol::locations_IsValid(value)) {
            set_location_type(static_cast< ::libbitcoin::protocol::locations >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.transactions_request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.transactions_request)
  return false;
#undef DO_
}

void transactions_request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.transactions_request)
  // optional .libbitcoin.protocol.block_id start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->start(), output);
  }

  // optional uint32 results_per_page = 2;
  if (has_results_per_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->results_per_page(), output);
  }

  // repeated .libbitcoin.protocol.filter query = 3;
  for (int i = 0; i < this->query_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->query(i), output);
  }

  // optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
  if (has_result_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->result_type(), output);
  }

  // optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
  if (has_location_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->location_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.transactions_request)
}

::google::protobuf::uint8* transactions_request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.transactions_request)
  // optional .libbitcoin.protocol.block_id start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->start(), target);
  }

  // optional uint32 results_per_page = 2;
  if (has_results_per_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->results_per_page(), target);
  }

  // repeated .libbitcoin.protocol.filter query = 3;
  for (int i = 0; i < this->query_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->query(i), target);
  }

  // optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
  if (has_result_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->result_type(), target);
  }

  // optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
  if (has_location_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->location_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.transactions_request)
  return target;
}

int transactions_request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .libbitcoin.protocol.block_id start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->start());
    }

    // optional uint32 results_per_page = 2;
    if (has_results_per_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->results_per_page());
    }

    // optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
    if (has_result_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_type());
    }

    // optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
    if (has_location_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->location_type());
    }

  }
  // repeated .libbitcoin.protocol.filter query = 3;
  total_size += 1 * this->query_size();
  for (int i = 0; i < this->query_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->query(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void transactions_request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const transactions_request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const transactions_request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void transactions_request::MergeFrom(const transactions_request& from) {
  GOOGLE_CHECK_NE(&from, this);
  query_.MergeFrom(from.query_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      mutable_start()->::libbitcoin::protocol::block_id::MergeFrom(from.start());
    }
    if (from.has_results_per_page()) {
      set_results_per_page(from.results_per_page());
    }
    if (from.has_result_type()) {
      set_result_type(from.result_type());
    }
    if (from.has_location_type()) {
      set_location_type(from.location_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void transactions_request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void transactions_request::CopyFrom(const transactions_request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool transactions_request::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->query())) return false;
  return true;
}

void transactions_request::Swap(transactions_request* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    std::swap(results_per_page_, other->results_per_page_);
    query_.Swap(&other->query_);
    std::swap(result_type_, other->result_type_);
    std::swap(location_type_, other->location_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata transactions_request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = transactions_request_descriptor_;
  metadata.reflection = transactions_request_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int request::kIdFieldNumber;
const int request::kGetBlockHeadersFieldNumber;
const int request::kGetTransactionsFieldNumber;
const int request::kPostTransactionFieldNumber;
const int request::kValidateTransactionFieldNumber;
const int request::kPostBlockFieldNumber;
const int request::kValidateBlockFieldNumber;
#endif  // !_MSC_VER

request::request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.request)
}

void request::InitAsDefaultInstance() {
  request_default_oneof_instance_->get_block_headers_ = const_cast< ::libbitcoin::protocol::block_headers_request*>(&::libbitcoin::protocol::block_headers_request::default_instance());
  request_default_oneof_instance_->get_transactions_ = const_cast< ::libbitcoin::protocol::transactions_request*>(&::libbitcoin::protocol::transactions_request::default_instance());
  request_default_oneof_instance_->post_transaction_ = const_cast< ::libbitcoin::protocol::tx*>(&::libbitcoin::protocol::tx::default_instance());
  request_default_oneof_instance_->validate_transaction_ = const_cast< ::libbitcoin::protocol::tx*>(&::libbitcoin::protocol::tx::default_instance());
  request_default_oneof_instance_->post_block_ = const_cast< ::libbitcoin::protocol::block*>(&::libbitcoin::protocol::block::default_instance());
  request_default_oneof_instance_->validate_block_ = const_cast< ::libbitcoin::protocol::block*>(&::libbitcoin::protocol::block::default_instance());
}

request::request(const request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.request)
}

void request::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_request_type();
}

request::~request() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.request)
  SharedDtor();
}

void request::SharedDtor() {
  if (has_request_type()) {
    clear_request_type();
  }
  if (this != default_instance_) {
  }
}

void request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return request_descriptor_;
}

const request& request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

request* request::default_instance_ = NULL;

request* request::New() const {
  return new request;
}

void request::clear_request_type() {
  switch(request_type_case()) {
    case kGetBlockHeaders: {
      delete request_type_.get_block_headers_;
      break;
    }
    case kGetTransactions: {
      delete request_type_.get_transactions_;
      break;
    }
    case kPostTransaction: {
      delete request_type_.post_transaction_;
      break;
    }
    case kValidateTransaction: {
      delete request_type_.validate_transaction_;
      break;
    }
    case kPostBlock: {
      delete request_type_.post_block_;
      break;
    }
    case kValidateBlock: {
      delete request_type_.validate_block_;
      break;
    }
    case REQUEST_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}


void request::Clear() {
  _extensions_.Clear();
  id_ = 0u;
  clear_request_type();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_get_block_headers;
        break;
      }

      // optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
      case 2: {
        if (tag == 18) {
         parse_get_block_headers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_block_headers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_get_transactions;
        break;
      }

      // optional .libbitcoin.protocol.transactions_request get_transactions = 3;
      case 3: {
        if (tag == 26) {
         parse_get_transactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_transactions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_post_transaction;
        break;
      }

      // optional .libbitcoin.protocol.tx post_transaction = 4;
      case 4: {
        if (tag == 34) {
         parse_post_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_post_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_validate_transaction;
        break;
      }

      // optional .libbitcoin.protocol.tx validate_transaction = 5;
      case 5: {
        if (tag == 42) {
         parse_validate_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_validate_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_post_block;
        break;
      }

      // optional .libbitcoin.protocol.block post_block = 6;
      case 6: {
        if (tag == 50) {
         parse_post_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_post_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_validate_block;
        break;
      }

      // optional .libbitcoin.protocol.block validate_block = 7;
      case 7: {
        if (tag == 58) {
         parse_validate_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_validate_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((800u <= tag && tag < 1600u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.request)
  return false;
#undef DO_
}

void request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.request)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
  if (has_get_block_headers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->get_block_headers(), output);
  }

  // optional .libbitcoin.protocol.transactions_request get_transactions = 3;
  if (has_get_transactions()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_transactions(), output);
  }

  // optional .libbitcoin.protocol.tx post_transaction = 4;
  if (has_post_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->post_transaction(), output);
  }

  // optional .libbitcoin.protocol.tx validate_transaction = 5;
  if (has_validate_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->validate_transaction(), output);
  }

  // optional .libbitcoin.protocol.block post_block = 6;
  if (has_post_block()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->post_block(), output);
  }

  // optional .libbitcoin.protocol.block validate_block = 7;
  if (has_validate_block()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->validate_block(), output);
  }

  // Extension range [100, 200)
  _extensions_.SerializeWithCachedSizes(
      100, 200, output);

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.request)
}

::google::protobuf::uint8* request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.request)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
  if (has_get_block_headers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->get_block_headers(), target);
  }

  // optional .libbitcoin.protocol.transactions_request get_transactions = 3;
  if (has_get_transactions()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_transactions(), target);
  }

  // optional .libbitcoin.protocol.tx post_transaction = 4;
  if (has_post_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->post_transaction(), target);
  }

  // optional .libbitcoin.protocol.tx validate_transaction = 5;
  if (has_validate_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->validate_transaction(), target);
  }

  // optional .libbitcoin.protocol.block post_block = 6;
  if (has_post_block()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->post_block(), target);
  }

  // optional .libbitcoin.protocol.block validate_block = 7;
  if (has_validate_block()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->validate_block(), target);
  }

  // Extension range [100, 200)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 200, target);

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.request)
  return target;
}

int request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  switch (request_type_case()) {
    // optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
    case kGetBlockHeaders: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_block_headers());
      break;
    }
    // optional .libbitcoin.protocol.transactions_request get_transactions = 3;
    case kGetTransactions: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_transactions());
      break;
    }
    // optional .libbitcoin.protocol.tx post_transaction = 4;
    case kPostTransaction: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->post_transaction());
      break;
    }
    // optional .libbitcoin.protocol.tx validate_transaction = 5;
    case kValidateTransaction: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->validate_transaction());
      break;
    }
    // optional .libbitcoin.protocol.block post_block = 6;
    case kPostBlock: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->post_block());
      break;
    }
    // optional .libbitcoin.protocol.block validate_block = 7;
    case kValidateBlock: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->validate_block());
      break;
    }
    case REQUEST_TYPE_NOT_SET: {
      break;
    }
  }
  total_size += _extensions_.ByteSize();

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void request::MergeFrom(const request& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch (from.request_type_case()) {
    case kGetBlockHeaders: {
      mutable_get_block_headers()->::libbitcoin::protocol::block_headers_request::MergeFrom(from.get_block_headers());
      break;
    }
    case kGetTransactions: {
      mutable_get_transactions()->::libbitcoin::protocol::transactions_request::MergeFrom(from.get_transactions());
      break;
    }
    case kPostTransaction: {
      mutable_post_transaction()->::libbitcoin::protocol::tx::MergeFrom(from.post_transaction());
      break;
    }
    case kValidateTransaction: {
      mutable_validate_transaction()->::libbitcoin::protocol::tx::MergeFrom(from.validate_transaction());
      break;
    }
    case kPostBlock: {
      mutable_post_block()->::libbitcoin::protocol::block::MergeFrom(from.post_block());
      break;
    }
    case kValidateBlock: {
      mutable_validate_block()->::libbitcoin::protocol::block::MergeFrom(from.validate_block());
      break;
    }
    case REQUEST_TYPE_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void request::CopyFrom(const request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_get_transactions()) {
    if (!this->get_transactions().IsInitialized()) return false;
  }
  if (has_post_transaction()) {
    if (!this->post_transaction().IsInitialized()) return false;
  }
  if (has_validate_transaction()) {
    if (!this->validate_transaction().IsInitialized()) return false;
  }
  if (has_post_block()) {
    if (!this->post_block().IsInitialized()) return false;
  }
  if (has_validate_block()) {
    if (!this->validate_block().IsInitialized()) return false;
  }

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void request::Swap(request* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(request_type_, other->request_type_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = request_descriptor_;
  metadata.reflection = request_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int response_block_headers::kNextFieldNumber;
const int response_block_headers::kTopFieldNumber;
const int response_block_headers::kHeadersFieldNumber;
#endif  // !_MSC_VER

response_block_headers::response_block_headers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.response.block_headers)
}

void response_block_headers::InitAsDefaultInstance() {
  next_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
  top_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
}

response_block_headers::response_block_headers(const response_block_headers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.response.block_headers)
}

void response_block_headers::SharedCtor() {
  _cached_size_ = 0;
  next_ = NULL;
  top_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

response_block_headers::~response_block_headers() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.response.block_headers)
  SharedDtor();
}

void response_block_headers::SharedDtor() {
  if (this != default_instance_) {
    delete next_;
    delete top_;
  }
}

void response_block_headers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* response_block_headers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return response_block_headers_descriptor_;
}

const response_block_headers& response_block_headers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

response_block_headers* response_block_headers::default_instance_ = NULL;

response_block_headers* response_block_headers::New() const {
  return new response_block_headers;
}

void response_block_headers::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_next()) {
      if (next_ != NULL) next_->::libbitcoin::protocol::block_id::Clear();
    }
    if (has_top()) {
      if (top_ != NULL) top_->::libbitcoin::protocol::block_id::Clear();
    }
  }
  headers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool response_block_headers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.response.block_headers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libbitcoin.protocol.block_id next = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_next()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_top;
        break;
      }

      // optional .libbitcoin.protocol.block_id top = 2;
      case 2: {
        if (tag == 18) {
         parse_top:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_top()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_headers;
        break;
      }

      // repeated .libbitcoin.protocol.block_header headers = 3;
      case 3: {
        if (tag == 26) {
         parse_headers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_headers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_headers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.response.block_headers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.response.block_headers)
  return false;
#undef DO_
}

void response_block_headers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.response.block_headers)
  // optional .libbitcoin.protocol.block_id next = 1;
  if (has_next()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->next(), output);
  }

  // optional .libbitcoin.protocol.block_id top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->top(), output);
  }

  // repeated .libbitcoin.protocol.block_header headers = 3;
  for (int i = 0; i < this->headers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->headers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.response.block_headers)
}

::google::protobuf::uint8* response_block_headers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.response.block_headers)
  // optional .libbitcoin.protocol.block_id next = 1;
  if (has_next()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->next(), target);
  }

  // optional .libbitcoin.protocol.block_id top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->top(), target);
  }

  // repeated .libbitcoin.protocol.block_header headers = 3;
  for (int i = 0; i < this->headers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->headers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.response.block_headers)
  return target;
}

int response_block_headers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .libbitcoin.protocol.block_id next = 1;
    if (has_next()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->next());
    }

    // optional .libbitcoin.protocol.block_id top = 2;
    if (has_top()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->top());
    }

  }
  // repeated .libbitcoin.protocol.block_header headers = 3;
  total_size += 1 * this->headers_size();
  for (int i = 0; i < this->headers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->headers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void response_block_headers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const response_block_headers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const response_block_headers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void response_block_headers::MergeFrom(const response_block_headers& from) {
  GOOGLE_CHECK_NE(&from, this);
  headers_.MergeFrom(from.headers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_next()) {
      mutable_next()->::libbitcoin::protocol::block_id::MergeFrom(from.next());
    }
    if (from.has_top()) {
      mutable_top()->::libbitcoin::protocol::block_id::MergeFrom(from.top());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void response_block_headers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void response_block_headers::CopyFrom(const response_block_headers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool response_block_headers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->headers())) return false;
  return true;
}

void response_block_headers::Swap(response_block_headers* other) {
  if (other != this) {
    std::swap(next_, other->next_);
    std::swap(top_, other->top_);
    headers_.Swap(&other->headers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata response_block_headers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = response_block_headers_descriptor_;
  metadata.reflection = response_block_headers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int response_transactions::kNextFieldNumber;
const int response_transactions::kTopFieldNumber;
const int response_transactions::kHashesFieldNumber;
const int response_transactions::kTransactionsFieldNumber;
const int response_transactions::kUtxosFieldNumber;
#endif  // !_MSC_VER

response_transactions::response_transactions()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.response.transactions)
}

void response_transactions::InitAsDefaultInstance() {
  next_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
  top_ = const_cast< ::libbitcoin::protocol::block_id*>(&::libbitcoin::protocol::block_id::default_instance());
}

response_transactions::response_transactions(const response_transactions& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.response.transactions)
}

void response_transactions::SharedCtor() {
  _cached_size_ = 0;
  next_ = NULL;
  top_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

response_transactions::~response_transactions() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.response.transactions)
  SharedDtor();
}

void response_transactions::SharedDtor() {
  if (this != default_instance_) {
    delete next_;
    delete top_;
  }
}

void response_transactions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* response_transactions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return response_transactions_descriptor_;
}

const response_transactions& response_transactions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

response_transactions* response_transactions::default_instance_ = NULL;

response_transactions* response_transactions::New() const {
  return new response_transactions;
}

void response_transactions::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_next()) {
      if (next_ != NULL) next_->::libbitcoin::protocol::block_id::Clear();
    }
    if (has_top()) {
      if (top_ != NULL) top_->::libbitcoin::protocol::block_id::Clear();
    }
  }
  hashes_.Clear();
  transactions_.Clear();
  utxos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool response_transactions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.response.transactions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libbitcoin.protocol.block_id next = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_next()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_top;
        break;
      }

      // optional .libbitcoin.protocol.block_id top = 2;
      case 2: {
        if (tag == 18) {
         parse_top:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_top()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_hashes;
        break;
      }

      // repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
      case 3: {
        if (tag == 26) {
         parse_hashes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hashes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_hashes;
        if (input->ExpectTag(34)) goto parse_transactions;
        break;
      }

      // repeated .libbitcoin.protocol.tx_result transactions = 4;
      case 4: {
        if (tag == 34) {
         parse_transactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transactions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_transactions;
        if (input->ExpectTag(42)) goto parse_utxos;
        break;
      }

      // repeated .libbitcoin.protocol.utxo_result utxos = 5;
      case 5: {
        if (tag == 42) {
         parse_utxos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_utxos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_utxos;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.response.transactions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.response.transactions)
  return false;
#undef DO_
}

void response_transactions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.response.transactions)
  // optional .libbitcoin.protocol.block_id next = 1;
  if (has_next()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->next(), output);
  }

  // optional .libbitcoin.protocol.block_id top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->top(), output);
  }

  // repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
  for (int i = 0; i < this->hashes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->hashes(i), output);
  }

  // repeated .libbitcoin.protocol.tx_result transactions = 4;
  for (int i = 0; i < this->transactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->transactions(i), output);
  }

  // repeated .libbitcoin.protocol.utxo_result utxos = 5;
  for (int i = 0; i < this->utxos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->utxos(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.response.transactions)
}

::google::protobuf::uint8* response_transactions::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.response.transactions)
  // optional .libbitcoin.protocol.block_id next = 1;
  if (has_next()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->next(), target);
  }

  // optional .libbitcoin.protocol.block_id top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->top(), target);
  }

  // repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
  for (int i = 0; i < this->hashes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->hashes(i), target);
  }

  // repeated .libbitcoin.protocol.tx_result transactions = 4;
  for (int i = 0; i < this->transactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->transactions(i), target);
  }

  // repeated .libbitcoin.protocol.utxo_result utxos = 5;
  for (int i = 0; i < this->utxos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->utxos(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.response.transactions)
  return target;
}

int response_transactions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .libbitcoin.protocol.block_id next = 1;
    if (has_next()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->next());
    }

    // optional .libbitcoin.protocol.block_id top = 2;
    if (has_top()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->top());
    }

  }
  // repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
  total_size += 1 * this->hashes_size();
  for (int i = 0; i < this->hashes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hashes(i));
  }

  // repeated .libbitcoin.protocol.tx_result transactions = 4;
  total_size += 1 * this->transactions_size();
  for (int i = 0; i < this->transactions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transactions(i));
  }

  // repeated .libbitcoin.protocol.utxo_result utxos = 5;
  total_size += 1 * this->utxos_size();
  for (int i = 0; i < this->utxos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->utxos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void response_transactions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const response_transactions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const response_transactions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void response_transactions::MergeFrom(const response_transactions& from) {
  GOOGLE_CHECK_NE(&from, this);
  hashes_.MergeFrom(from.hashes_);
  transactions_.MergeFrom(from.transactions_);
  utxos_.MergeFrom(from.utxos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_next()) {
      mutable_next()->::libbitcoin::protocol::block_id::MergeFrom(from.next());
    }
    if (from.has_top()) {
      mutable_top()->::libbitcoin::protocol::block_id::MergeFrom(from.top());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void response_transactions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void response_transactions::CopyFrom(const response_transactions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool response_transactions::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->hashes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->transactions())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->utxos())) return false;
  return true;
}

void response_transactions::Swap(response_transactions* other) {
  if (other != this) {
    std::swap(next_, other->next_);
    std::swap(top_, other->top_);
    hashes_.Swap(&other->hashes_);
    transactions_.Swap(&other->transactions_);
    utxos_.Swap(&other->utxos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata response_transactions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = response_transactions_descriptor_;
  metadata.reflection = response_transactions_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int response::kIdFieldNumber;
const int response::kStatusFieldNumber;
const int response::kGetBlockHeadersResponseFieldNumber;
const int response::kGetTransactionsResponseFieldNumber;
const int response::kPostTransactionSucceededFieldNumber;
const int response::kValidateTransactionSucceededFieldNumber;
const int response::kPostBlockSucceededFieldNumber;
const int response::kValidateBlockSucceededFieldNumber;
#endif  // !_MSC_VER

response::response()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libbitcoin.protocol.response)
}

void response::InitAsDefaultInstance() {
  response_default_oneof_instance_->get_block_headers_response_ = const_cast< ::libbitcoin::protocol::response_block_headers*>(&::libbitcoin::protocol::response_block_headers::default_instance());
  response_default_oneof_instance_->get_transactions_response_ = const_cast< ::libbitcoin::protocol::response_transactions*>(&::libbitcoin::protocol::response_transactions::default_instance());
  response_default_oneof_instance_->post_transaction_succeeded_ = false;
  response_default_oneof_instance_->validate_transaction_succeeded_ = false;
  response_default_oneof_instance_->post_block_succeeded_ = false;
  response_default_oneof_instance_->validate_block_succeeded_ = false;
}

response::response(const response& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libbitcoin.protocol.response)
}

void response::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_response_type();
}

response::~response() {
  // @@protoc_insertion_point(destructor:libbitcoin.protocol.response)
  SharedDtor();
}

void response::SharedDtor() {
  if (has_response_type()) {
    clear_response_type();
  }
  if (this != default_instance_) {
  }
}

void response::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* response::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return response_descriptor_;
}

const response& response::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  return *default_instance_;
}

response* response::default_instance_ = NULL;

response* response::New() const {
  return new response;
}

void response::clear_response_type() {
  switch(response_type_case()) {
    case kGetBlockHeadersResponse: {
      delete response_type_.get_block_headers_response_;
      break;
    }
    case kGetTransactionsResponse: {
      delete response_type_.get_transactions_response_;
      break;
    }
    case kPostTransactionSucceeded: {
      // No need to clear
      break;
    }
    case kValidateTransactionSucceeded: {
      // No need to clear
      break;
    }
    case kPostBlockSucceeded: {
      // No need to clear
      break;
    }
    case kValidateBlockSucceeded: {
      // No need to clear
      break;
    }
    case RESPONSE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}


void response::Clear() {
  _extensions_.Clear();
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<response*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  clear_response_type();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libbitcoin.protocol.response)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional sint32 status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_get_block_headers_response;
        break;
      }

      // optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
      case 3: {
        if (tag == 26) {
         parse_get_block_headers_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_block_headers_response()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_get_transactions_response;
        break;
      }

      // optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
      case 4: {
        if (tag == 34) {
         parse_get_transactions_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_transactions_response()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_post_transaction_succeeded;
        break;
      }

      // optional bool post_transaction_succeeded = 5;
      case 5: {
        if (tag == 40) {
         parse_post_transaction_succeeded:
          clear_response_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &response_type_.post_transaction_succeeded_)));
          set_has_post_transaction_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_validate_transaction_succeeded;
        break;
      }

      // optional bool validate_transaction_succeeded = 6;
      case 6: {
        if (tag == 48) {
         parse_validate_transaction_succeeded:
          clear_response_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &response_type_.validate_transaction_succeeded_)));
          set_has_validate_transaction_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_post_block_succeeded;
        break;
      }

      // optional bool post_block_succeeded = 7;
      case 7: {
        if (tag == 56) {
         parse_post_block_succeeded:
          clear_response_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &response_type_.post_block_succeeded_)));
          set_has_post_block_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_validate_block_succeeded;
        break;
      }

      // optional bool validate_block_succeeded = 8;
      case 8: {
        if (tag == 64) {
         parse_validate_block_succeeded:
          clear_response_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &response_type_.validate_block_succeeded_)));
          set_has_validate_block_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((800u <= tag && tag < 1600u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libbitcoin.protocol.response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libbitcoin.protocol.response)
  return false;
#undef DO_
}

void response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libbitcoin.protocol.response)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional sint32 status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->status(), output);
  }

  // optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
  if (has_get_block_headers_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_block_headers_response(), output);
  }

  // optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
  if (has_get_transactions_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->get_transactions_response(), output);
  }

  // optional bool post_transaction_succeeded = 5;
  if (has_post_transaction_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->post_transaction_succeeded(), output);
  }

  // optional bool validate_transaction_succeeded = 6;
  if (has_validate_transaction_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->validate_transaction_succeeded(), output);
  }

  // optional bool post_block_succeeded = 7;
  if (has_post_block_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->post_block_succeeded(), output);
  }

  // optional bool validate_block_succeeded = 8;
  if (has_validate_block_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->validate_block_succeeded(), output);
  }

  // Extension range [100, 200)
  _extensions_.SerializeWithCachedSizes(
      100, 200, output);

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:libbitcoin.protocol.response)
}

::google::protobuf::uint8* response::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libbitcoin.protocol.response)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional sint32 status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->status(), target);
  }

  // optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
  if (has_get_block_headers_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_block_headers_response(), target);
  }

  // optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
  if (has_get_transactions_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->get_transactions_response(), target);
  }

  // optional bool post_transaction_succeeded = 5;
  if (has_post_transaction_succeeded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->post_transaction_succeeded(), target);
  }

  // optional bool validate_transaction_succeeded = 6;
  if (has_validate_transaction_succeeded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->validate_transaction_succeeded(), target);
  }

  // optional bool post_block_succeeded = 7;
  if (has_post_block_succeeded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->post_block_succeeded(), target);
  }

  // optional bool validate_block_succeeded = 8;
  if (has_validate_block_succeeded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->validate_block_succeeded(), target);
  }

  // Extension range [100, 200)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 200, target);

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:libbitcoin.protocol.response)
  return target;
}

int response::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional sint32 status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->status());
    }

  }
  switch (response_type_case()) {
    // optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
    case kGetBlockHeadersResponse: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_block_headers_response());
      break;
    }
    // optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
    case kGetTransactionsResponse: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_transactions_response());
      break;
    }
    // optional bool post_transaction_succeeded = 5;
    case kPostTransactionSucceeded: {
      total_size += 1 + 1;
      break;
    }
    // optional bool validate_transaction_succeeded = 6;
    case kValidateTransactionSucceeded: {
      total_size += 1 + 1;
      break;
    }
    // optional bool post_block_succeeded = 7;
    case kPostBlockSucceeded: {
      total_size += 1 + 1;
      break;
    }
    // optional bool validate_block_succeeded = 8;
    case kValidateBlockSucceeded: {
      total_size += 1 + 1;
      break;
    }
    case RESPONSE_TYPE_NOT_SET: {
      break;
    }
  }
  total_size += _extensions_.ByteSize();

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void response::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const response* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const response*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void response::MergeFrom(const response& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch (from.response_type_case()) {
    case kGetBlockHeadersResponse: {
      mutable_get_block_headers_response()->::libbitcoin::protocol::response_block_headers::MergeFrom(from.get_block_headers_response());
      break;
    }
    case kGetTransactionsResponse: {
      mutable_get_transactions_response()->::libbitcoin::protocol::response_transactions::MergeFrom(from.get_transactions_response());
      break;
    }
    case kPostTransactionSucceeded: {
      set_post_transaction_succeeded(from.post_transaction_succeeded());
      break;
    }
    case kValidateTransactionSucceeded: {
      set_validate_transaction_succeeded(from.validate_transaction_succeeded());
      break;
    }
    case kPostBlockSucceeded: {
      set_post_block_succeeded(from.post_block_succeeded());
      break;
    }
    case kValidateBlockSucceeded: {
      set_validate_block_succeeded(from.validate_block_succeeded());
      break;
    }
    case RESPONSE_TYPE_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void response::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void response::CopyFrom(const response& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool response::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_get_block_headers_response()) {
    if (!this->get_block_headers_response().IsInitialized()) return false;
  }
  if (has_get_transactions_response()) {
    if (!this->get_transactions_response().IsInitialized()) return false;
  }

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void response::Swap(response* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(status_, other->status_);
    std::swap(response_type_, other->response_type_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata response::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = response_descriptor_;
  metadata.reflection = response_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace libbitcoin

// @@protoc_insertion_point(global_scope)

#endif
